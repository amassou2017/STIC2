/* Main.c file generated by New Project wizard
 *
 * Created:   mer. févr. 17 2016
 * Processor: PIC16F887
 * Compiler:  MPLAB XC8
 */

#include <xc.h>

// CONFIG1
#pragma config FOSC = INTRC_CLKOUT// Oscillator Selection bits (INTOSC oscillator: CLKOUT function on RA6/OSC2/CLKOUT pin, I/O function on RA7/OSC1/CLKIN)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config MCLRE = ON       // RE3/MCLR pin function select bit (RE3/MCLR pin function is MCLR)
#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled)
#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled)
#pragma config BOREN = OFF      // Brown Out Reset Selection bits (BOR disabled)
#pragma config IESO = OFF       // Internal External Switchover bit (Internal/External Switchover mode is disabled)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled)
#pragma config LVP = OFF        // Low Voltage Programming Enable bit (RB3 pin has digital I/O, HV on MCLR must be used for programming)

// CONFIG2
#pragma config BOR4V = BOR40V   // Brown-out Reset Selection bit (Brown-out Reset set to 4.0V)
#pragma config WRT = OFF        // Flash Program Memory Self Write Enable bits (Write protection off)

#define _XTAL_FREQ 4000000

#define pushed   0
#define released 1
#define empty 1
#define not_empty 0
#define ON 0
#define OFF 1

#define button PORTBbits.RB0
#define sensor PORTBbits.RB1
#define motor  PORTBbits.RB2
#define LED_ET PORTDbits.RD0
#define LED_MP PORTDbits.RD1
#define Trigger PORTCbits.RC0
#define Echo PORTCbits.RC1
/* 7seg interface*/
#define DISP PORTCbits.RC2
#define LATCH PORTCbits.RC6
#define RST PORTCbits.RC7

unsigned char last_button, pushed_button, ccpconfig;
unsigned int d,last_ccp,current_ccp;

const unsigned short CharTable[51]={
    0x80, // '-'
    0x01, // '.'   Sevensegment bit order
    0x00, // '/'   (g)(f)(e)(d)(c)(a)(b)(dp)
    0x7E, // '0'
    0x0A, // '1'    _a_
    0xB6, // '2'  f|   |b
    0x9E, // '3'   |_g_|
    0xCA, // '4'  e|   |c
    0xDC, // '5'   |_d_|.dp
    0xFC, // '6'
    0x0E, // '7'
    0xFE, // '8'
    0xDE, // '9'
    0x00, // ':'
    0x00, // ';'
    0x00, // '<'
    0x00, // '='
    0x00, // '>'
    0x00, // '?'
    0x00, // '@'
    0xEE, // 'A'
    0xF8, // 'B'
    0x74, // 'C'
    0xBA, // 'D'
    0xF4, // 'E'
    0xE4, // 'F'
    0x7C, // 'G'
    0xEA, // 'H'
    0x0A, // 'I'
    0x3A, // 'J'
    0x00, // 'K'
    0x70, // 'L'
    0x00, // 'M'
    0x6E, // 'N'
    0x00, // 'O'
    0xE6, // 'P'
    0xCE, // 'Q'
    0x64, // 'R'
    0xDC, // 'S'
    0xF0, // 'T'
    0x7A, // 'U'
    0x00, // 'V'
    0x00, // 'W'
    0x00, // 'X'
    0xDA, // 'Y'
    0x00, // 'Z'
    0x00, // '['
    0x00, // '/'
    0x00, // ']'
    0x00, // '^'
    0x10, // '_'
};
const unsigned short IntTable[10]={
                // (g)(f)(e)(d)(c)(a)(b)(dp)
    0x7E, // '0'
    0x0A, // '1'    _a_
    0xB6, // '2'  f|   |b
    0x9E, // '3'   |_g_|
    0xCA, // '4'  e|   |c
    0xDC, // '5'   |_d_|.dp
    0xFC, // '6'
    0x0E, // '7'
    0xFE, // '8'
    0xDE, // '9
};
void display(char a, char b)
{
    SSPBUF=b;
    while(PIR1bits.SSPIF==0);
    PIR1bits.SSPIF=0;  
    SSPBUF=a;
    while(PIR1bits.SSPIF==0);
     PIR1bits.SSPIF=0;  
    LATCH=0;
    __delay_us(20);
    LATCH=1;  
}
void display_rst(void)
{
    RST=0;
    __delay_us(20);
    LATCH=0;
    __delay_us(20);
    LATCH=1;  
    RST=1;
}
void main(void)
 {
    OSCCON&=0b11101110;// use internal oscillator
    OSCCON|=0b01100000;// set it to 4 Mhz
    
    TRISD=0x00;// configure PORTD as output
    PORTD=0x00;// initialize PORTD to 0x00 :All LEDs are OFF
    ANSELH=0x00;
    OPTION_REGbits.nRBPU=0;
    WPUBbits.WPUB1=1;    
    TRISBbits.TRISB0=1;
    TRISBbits.TRISB1=1;
    TRISBbits.TRISB2=0;
    TRISCbits.TRISC0=0;//Trigger as Output
    TRISCbits.TRISC1=1;// Echo as Input :RC1 is CCP2
    /* 7seg Interface*/
    TRISCbits.TRISC2=0;//DISP as Output
    TRISCbits.TRISC3=0;//SCK as Output
    TRISCbits.TRISC5=0;//DS as Output
    TRISCbits.TRISC6=0;//LATCH as Output
    TRISCbits.TRISC7=0;//RESET as Output
    
    motor=OFF;
    LED_ET=0;
    LED_MP=0;
    last_button=button;
    pushed_button=0;
    
    T1CON=0x00;
    //using CCP2 for measering the pulse sent from the ultrasound module
    // configure CCP2: capture mode rising edge 
    CCP2CON=0x05;
    CCP2IF=0; /* Clear Interrupt flag of CCP2*/
    GIE=1;// enable globale interrupt
    PEIE=1;// enable peripheral interrupt
    CCP2IE=1;// enable CCP2 interrupt
    TMR1ON=1;// Start TMR1
    /*7 seg initialization*/
    DISP=1;
    RST=1;
    SSPCON=0x20;// SPI master, Enable SPI clock idle state low
    SSPSTATbits.CKE=1;// data transmitted on rising edge
    
    
    display(IntTable[0],IntTable[1]);
       
    __delay_ms(500);
    // reset display
    display_rst();
    
    display(IntTable[0],IntTable[2]);
    // Write your code here
   while (1)
   {
      if((last_button==released) && (button==pushed)) pushed_button=1;
      last_button=button;
      
      if (sensor==empty)LED_ET=1;
	  else LED_ET=0;
	    
      if (pushed_button)
      {
        pushed_button=0;
	 if(sensor==empty)
	 {  while(sensor==empty)
	    {
	       LED_ET=~LED_ET;
	     __delay_ms(500);   
	       }
	  }
	  else
	  {
	     LED_MP=1;
	     motor=ON;
	     while(sensor==not_empty);
	     LED_MP=0;
	     motor=OFF;
	   }
	   }
      /* send a pulse to the Ultrasound module via Trigger pin*/
      Trigger=1;// rise Trigger to 1
      __delay_us(10);// delay of 10 us 
      Trigger=0;// reset Trigger
      //d=TMR1L|(TMR1H<<8);// calculate the TMR1 counter register
      //d=(unsigned int)(d/58.82);// calculate the distance in cm
      __delay_ms(60); // delay of 60 ms
      
   }
 }
 
 void interrupt isr(void)
{
    /* This code stub shows general interrupt handling.  Note that these
    conditional statements are not handled within 3 seperate if blocks.
    Do not use a seperate if block for each interrupt flag to avoid run
    time errors. */
    
    /* TODO Add interrupt routine code here. */

    /* Determine which flag generated the interrupt */
    if((CCP2IF==1)&&(CCP2IE==1))
   {     
       ccpconfig=CCP2CON&0x0F;
     if(ccpconfig==0x05)//capture mode rising edge
     {
	last_ccp=CCPR2L|(CCPR2H<<8);//store capture values
	CCP2IE=0; // deactivate CCP2 interrupt
	CCP2CON=0x04;// switch capture mode to falling edge
	CCP2IF=0; /* Clear Interrupt*/
	CCP2IE=1; // activate CCP2 interrupt
	}
     else
	if(ccpconfig==0x04)//capture mode falling edge
          {
	     current_ccp=CCPR2L|(CCPR2H<<8);// store the capture registers
	     CCP2IE=0; // deactivate CCP2 interrupt
	     CCP2CON=0x05;// switch back again to capture mode rising edge
	     CCP2IF=0; /* Clear Interrupt*/
	     CCP2IE=1; // activate CCP2 interrupt
	     
	     // calculate the distance
	     if(current_ccp >= last_ccp)
	     {
		d=current_ccp - last_ccp;
		}else
		{
		   d=last_ccp - current_ccp;
		   }
	     }
       }
}
